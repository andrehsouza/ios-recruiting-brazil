//
//  ListMoviesPresenter.swift
//  DataMovie
//
//  Created by Andre on 12/08/2018.
//  Copyright (c) 2018 Andre. All rights reserved.
//
//  This file was generated by the 🐍 VIPER generator
//

import UIKit

final class ListMoviesPresenter {

    // MARK: - Private properties -

    private unowned var _view: ListMoviesViewInterface
    private var _interactor: ListMoviesInteractorInterface
    private var _wireframe: ListMoviesWireframeInterface
    private var _canLoadMoreMovies: Bool = true
    private var _isFilteringByTitle: Bool = false
    private var _needUpdateList: Bool = false
    private let _limit: Int = 12
    private var _movies: [MovieEntity] = [MovieEntity]()

    // MARK: - Lifecycle -

    init(wireframe: ListMoviesWireframeInterface, view: ListMoviesViewInterface, interactor: ListMoviesInteractorInterface) {
        _wireframe = wireframe
        _view = view
        _interactor = interactor
    }
}

// MARK: - Extensions -

extension ListMoviesPresenter: ListMoviesPresenterInterface {
    
    var footerMessage: String {
        if _movies.count == 0 {
            return _isFilteringByTitle ? "No results." : "No movies yet."
        }
        return ""
    }
    
    func refreshList() {
        if _needUpdateList && !_isFilteringByTitle {
            loadMoviesWithSelectedFilters()
            _needUpdateList = false
        }
    }
    
    func numberOfItems() -> Int {
        return _movies.count
    }
    
    func item(at indexPath: IndexPath) -> MovieListItem? {
        return _movies[indexPath.item]
    }
    
    func didSelectItem(at indexPath: IndexPath) {
        let movieEntity = _movies[indexPath.item]
        _wireframe.navigate(to: .detail(movieEntity: movieEntity, imageTransition: _view.imageTransition))
    }
    
    func addMovies(circularTransiction: CircularTransition) {
        _wireframe.navigate(to: .addMovie(transitionDelegate: _view, circularTransiction: circularTransiction, movieListUpdateProtocol: self))
    }
    
    func loadMovies() {
        if _canLoadMoreMovies && !_isFilteringByTitle {
            loadMoviesWithSelectedFilters()
        }
    }
    
    func filterMovies(by text: String) {
        if text.isEmpty {
            _movies.removeAll()
            loadMoviesWithSelectedFilters()
        } else {
            _isFilteringByTitle = true
            DispatchQueue.main.async {
                self._movies.removeAll()
                let newMovies = MovieEntity.findWhere(.contains(attributeName: "title", value: text)) ?? []
                self._movies = newMovies
                self._view.reloadData()
            }
        }
    }
    
    func touchFilterOptions() {
        let filterOptions: [AlertListMovieFilterModel] = [AlertListMovieFilterModel.init(buttonTitle: "Only favorites", userDefaultKey: .favorites),
                                                          AlertListMovieFilterModel.init(buttonTitle: "Not watched", userDefaultKey: .notWatched),
                                                          AlertListMovieFilterModel.init(buttonTitle: "Watched", userDefaultKey: .watched)]
        
        _view.showFilterOptions(withProtocol: self, andFilterList: filterOptions)
    }
    
}

// MARK: - AlertFiterActionProtocol -

extension ListMoviesPresenter: AlertFiterActionProtocol {
    
    func didChangeFilter(value: Bool, _ userDefaultKey: MovieListFilters.BoolDefaultKey) {
        UserDefaults.movieListFilters.set(value, forKey: userDefaultKey)
        _movies.removeAll()
        loadMoviesWithSelectedFilters()
    }
    
}

// MARK: - ListMoviesUpdateProtocol -

extension ListMoviesPresenter: MovieListUpdateProtocol {
    
    func setNeedUpdateList() {
        _needUpdateList = true
    }
    
}

// MARK: - Functions -

extension ListMoviesPresenter {

     private func loadMoviesWithSelectedFilters() {
        DispatchQueue.main.async {
            var filters: [MovieListFilter] = []
            
            let isFavoriteOn = UserDefaults.movieListFilters.bool(forKey: .favorites)
            let isWatchedOn = UserDefaults.movieListFilters.bool(forKey: .watched)
            let isNotWatchedOn = UserDefaults.movieListFilters.bool(forKey: .notWatched)
            
            if isFavoriteOn {
                filters.append(.onlyFavorites)
            }
            if isWatchedOn != isNotWatchedOn {
                filters.append(.onlyWatched(watched: (isWatchedOn || !isNotWatchedOn)))
            }
            
            let newMovies = MovieEntity.fetchAllFiltering(movieListFilter: filters,
                                                          offSet: self._movies.count,
                                                            limit: self._limit) ?? []
            self._isFilteringByTitle = false
            self._canLoadMoreMovies = !newMovies.isEmpty
            self._movies.append(contentsOf: newMovies)
            self._view.reloadData()
            debugPrint("####### LOADING MORE #######")
        }
    }

}
