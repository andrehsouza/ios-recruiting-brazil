//
//  MovieDetailPresenter.swift
//  DataMovie
//
//  Created by Andre Souza on 14/08/2018.
//  Copyright (c) 2018 Andre. All rights reserved.
//
//  This file was generated by the 🐍 VIPER generator
//

import UIKit
import Alamofire
import AlamofireImage

final class MovieDetailPresenter {

    // MARK: - Private properties -

    private unowned var _view: MovieDetailViewInterface
    
    private var _viewOverview: MovieDetailOverviewInterface
    private var _viewTrailerList: MovieDetailListViewInterface
    private var _viewRelatedList: MovieDetailListViewInterface
    
    private var _interactor: MovieDetailInteractorInterface
    private var _wireframe: MovieDetailWireframeInterface
    private var _movieEntity: MovieEntity
    private var _discoverMovieList = DiscoverMovieListModel()
    private var _transition: ImageAnimatorTransition

    var movieListCellDetailViewProtocol: MovieListCellDetailViewProtocol?
    
    // MARK: - Lifecycle -

    init(wireframe: MovieDetailWireframeInterface, view: MovieDetailViewInterface,  interactor: MovieDetailInteractorInterface, movieEntity: MovieEntity, transition: ImageAnimatorTransition) {
        
        _viewOverview = MovieDetailOverviewViewController.newInstance()
        _viewTrailerList = MovieDetailListViewController.newInstance(detailContent: .trailer)
        _viewRelatedList = MovieDetailListViewController.newInstance(detailContent: .related)
        
        _wireframe = wireframe
        _view = view
        _interactor = interactor
        _movieEntity = movieEntity
        _transition = transition
        _transition.toDelegate = _view
    }
}

// MARK: - Extensions -

extension MovieDetailPresenter: MovieDetailPresenterInterface {
    
    var movieEntity: MovieViewDetail {
        return _movieEntity
    }
    
    var topCardviewHeight: CGFloat {
        return _view.topCardviewHeight
    }
    
    var fromDelegate: UINavigationControllerDelegate? {
        return _transition.fromDelegate
    }
    
    func numberOfGenre() -> Int {
        return _movieEntity.genresSorted.count
    }
    
    func genre(at indexPath: IndexPath) -> String {
        return _movieEntity.genresSorted[indexPath.row]
    }
    
    func numberOfCast() -> Int {
        return _movieEntity.castSorted.count
    }
    
    func person(at indexPath: IndexPath) -> CastEntity {
        return _movieEntity.castSorted[indexPath.row]
    }
    
    func loadPosterImage(_ imageView: UIImageView, at indexPath: IndexPath) {
        let movie = _discoverMovieList.results[indexPath.row]
        if let posterPath = movie.posterPath, !posterPath.isEmpty,
            let url = URL(string: TMDBUrl.image(.w200, posterPath).url) {
            imageView.af_setImage(withURL: url, placeholderImage: #imageLiteral(resourceName: "ic_place_holder"))
        } else {
            imageView.image = #imageLiteral(resourceName: "ic_place_holder")
        }
    }
    
    func loadPersonPicture(_ imageView: UIImageView, at indexPath: IndexPath) {
        let person = _movieEntity.castSorted[indexPath.item]
        let imgPlaceHolder = person.genderType == .woman ? #imageLiteral(resourceName: "ic_female") : #imageLiteral(resourceName: "ic_male")
        if let imagePath = person.profilePicture, !imagePath.isEmpty,
            let url = URL(string: TMDBUrl.image(.w200, imagePath).url) {
            imageView.af_setImage(withURL: url, placeholderImage: imgPlaceHolder)
        } else {
            imageView.image = imgPlaceHolder
        }
    }
    
    func touchZoomPoster() {
        _wireframe.navigate(to: .zoomImage(moviedetail: _movieEntity, imageTransition: _view.imageTransition))
    }
    
    func didSelectTrailer(at indexPath: IndexPath) {
        let youtubeId = _movieEntity.videosSorted[indexPath.row].key
        if let youtubeUrl = URL(string: TMDBUrl.video(youtubeId).url) {
            let safariVC = Util.newSFSafariInstance(with: youtubeUrl)
            _wireframe.show(safariVC, with: .present(completion: nil), animated: true)
        }
    }
    
    func didSelectCast(at indexPath: IndexPath, cacheImage: UIImage?) {
        let personEntity = _movieEntity.castSorted[indexPath.item]
        let personDetail = PersonDetailModel(personID: Int(personEntity.personID),
                                             name: personEntity.name,
                                             profileBgImage: _movieEntity.poster,
                                             cachePicture: cacheImage)
        _wireframe.navigate(to: .personDetail(personDetail: personDetail))
    }
    
    func activeViewController(at index: MovieDetailContent) -> UIViewController {
        switch index {
        case .overview:
            return _viewOverview.viewController
        case .trailer:
            return _viewTrailerList.viewController
        case .related:
            return _viewRelatedList.viewController
        }
    }
    
    func initSegmentedViewControllers() {
        MovieDetailContent.allCases.forEach() { content in
            _view.insertSegment(title: content.title, at: content.rawValue)
        }
        _view.selectedSegmentIndex = .overview
    }
    
    func touchDidWatch() {
        _movieEntity.didWatch = !_movieEntity.didWatch
        _movieEntity.save()
    }
    
    func touchFavorite() {
        _movieEntity.isFavorite = !_movieEntity.isFavorite
        _movieEntity.save()
    }
    
    func didRateMovie(value: CGFloat) {
        _movieEntity.personalRating = Float(value)
        _movieEntity.save()
    }
    
    func touchHomepage() {
        if let homePageString = _movieEntity.homepage, let homePageURL = URL(string: homePageString) {
            let safariVC = Util.newSFSafariInstance(with: homePageURL)
            _wireframe.show(safariVC, with: .present(completion: nil), animated: true)
        }
    }
    
    func viewDidLoad() {
        _viewOverview.presenter = self
        _viewTrailerList.presenter = self
        _viewRelatedList.presenter = self
    }
    
    //List
    
    func loadRelatedMovies() {
        requestMovieRelatedList()
    }
    
    func discoverItem(at indexPath: IndexPath) -> DiscoverItemListView? {
        return _discoverMovieList.results[safeIndex: indexPath.row]
    }
    
    func video(at indexPath: IndexPath) -> VideoEntity? {
        return _movieEntity.videosSorted[safeIndex: indexPath.row]
    }
    
    func numberOfSections(at detailContent: MovieDetailContent) -> Int {
        return 1
    }
    
    func numberOfItems(at detailContent: MovieDetailContent, in section: Int) -> Int {
        if detailContent == .trailer {
            return _movieEntity.videosSorted.count
        } else if detailContent == .related {
            return _discoverMovieList.results.count
        }
        
        return 0
    }
    
    func showStatus(_ status: DMButtonStatus, at indexPath: IndexPath) {
        _discoverMovieList.results[indexPath.row].buttonStatus = status
        _viewRelatedList.reloadData(at: indexPath)
        movieListCellDetailViewProtocol?.updateButtonStatus(status)
    }
    
    func updateItemStatus(with movieID: Int, isComplete: Bool) {
        if let rowIndex = _discoverMovieList.results.enumerated().filter({ $0.element.tmdbID == movieID }).map({ $0.offset }).first {
            let status: DMButtonStatus = isComplete ? .done : .normal(nil, #imageLiteral(resourceName: "ic_plus"), true)
            let indexPath = IndexPath(row: rowIndex, section: 0)
            showStatus(status, at: indexPath)
        }
    }
    
    func addMovie(indexPath: IndexPath) {
        if let tmdbID = findIDForMovie(at: indexPath) {
            showStatus(.loading, at: indexPath)
            addMovie(with: tmdbID)
        }
    }
    
    func didSelectRelatedMovie(at indexPath: IndexPath) {
        let detailVC = MovieListCellDetailViewController.newInstance(addProtocol: self, indexPath: indexPath)
        _wireframe.show(detailVC, with: .push, animated: true)
    }
    
    
}

// MARK: - AddMoviesProtocol -

extension MovieDetailPresenter: AddMoviesProtocol {
    
    func addMovie(with tmdbID: Int) {
        requestQueue(with: tmdbID)
    }
    
}

// MARK: - Load items -

extension MovieDetailPresenter {
    
    private func saveMovie(_ movieModel: MovieModel) {
        guard let tmdbID = movieModel.tmdbID else { return }
        updateItemStatus(with: tmdbID, isComplete: true)
        let movieEntity = MovieEntity(with: movieModel)
        movieEntity.save()
    }
    
    private func _handleFeedResult(_ result: RequestResultType<DiscoverMovieListModel>) {
        switch result {
        case .success(let list):
            incrementResult(list)
            break
        case .failure(let errorResponse):
            _viewRelatedList.showFooterMessage(message: (errorResponse.message ?? ""), buttonText: "Try again", target: self, action: #selector(requestMovieRelatedList))
            break
        }
    }
    
    private func incrementResult(_ discoverList: DiscoverMovieListModel) {
        _discoverMovieList.page = discoverList.page
        _discoverMovieList.totalPages = discoverList.totalPages
        _discoverMovieList.totalResults = discoverList.totalResults
        _discoverMovieList.results.append(contentsOf: discoverList.results)
        _viewRelatedList.resizeTableview()
        _viewRelatedList.reloadData()
        
        if discoverList.totalResults == 0 {
            _viewRelatedList.showFooterMessage(message: "No results.")
        } else if _discoverMovieList.page < _discoverMovieList.totalPages {
            _viewRelatedList.showFooterMessage(message: "", buttonText: "Load more", target: self, action: #selector(requestMovieRelatedList))
        } else {
            _viewRelatedList.showFooterMessage(message: "No more movies.")
        }
    }
    
    private func findIDForMovie(at indexPath: IndexPath) -> Int? {
        let tmdbID = _discoverMovieList.results[indexPath.row].tmdbID
        if tmdbID == nil {
            _wireframe.showErrorAlert(with: "Sorry, it wasn't possible to add this movie")
        }
        return tmdbID
    }
    
}

// MARK: - Rquests -

extension MovieDetailPresenter {
    
    @objc private func requestMovieRelatedList() {
        _viewRelatedList.showFooterLoading(text: "Loading items...")
        let page = _discoverMovieList.page+1
        let movieID = Int(_movieEntity.tmdbID)
        _interactor.getRecommendationsFor(movieID: movieID, page: page, { [weak self] result in
            self?._handleFeedResult(result)
        })
    }
    
    private func requestQueue(with tmdbID: Int) {
        
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            
            guard let self = self else {
                return
            }
            
            // MARK: - Initial variables
            
            var hasError: Bool = false
            var newMovie: MovieModel?
            let errorResponse: ErrorResponse = ErrorResponse("An error has occurred during download.\nPlease try again.")
            
            let dispatchGroup = DispatchGroup()
            
            // MARK: - REQUEST movie detail
            
            dispatchGroup.enter()
            self._interactor.getMovieDetail(tmdbID: tmdbID, { result in
                switch result {
                case .success(let detail):
                    newMovie = detail
                    break
                case .failure(_):
                    hasError = true
                    break
                }
                dispatchGroup.leave()
            })
            dispatchGroup.wait()
            
            // MARK: - REQUEST movie poster
            
            if !hasError, let posterPath = newMovie?.posterPath {
                dispatchGroup.enter()
                self._interactor.downloadPoster(posterPath: posterPath, { response in
                    switch(response.result) {
                    case .success(let imageData):
                        
                        guard
                            let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first
                        else { fallthrough }
                        
                        let imageFileName = posterPath.replacingOccurrences(of: "/", with: "")
                        let imageFileURL = fileURL.appendingPathComponent(imageFileName)
                        
                        do {
                            try imageData.write(to: imageFileURL, options: [.atomic])
                            newMovie?.posterPath = imageFileName
                        } catch {
                            hasError = true
                        }
                        
                        break
                    case .failure(_):
                        hasError = true
                        break
                    }
                    dispatchGroup.leave()
                })
                dispatchGroup.wait()
            }
            
            // MARK: - End of the block
            
            DispatchQueue.main.async {
                self.updateItemStatus(with: tmdbID, isComplete: !hasError)
                if hasError {
                    self._wireframe.showAlert(with: errorResponse.title, message: errorResponse.message)
                } else if let movie = newMovie {
                    self.saveMovie(movie)
                }
            }
        }
    }
}
